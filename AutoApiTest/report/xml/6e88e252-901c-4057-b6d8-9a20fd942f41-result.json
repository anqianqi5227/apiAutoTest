{"name": "test_case[login0-case_data0]", "status": "broken", "statusDetails": {"message": "requests.exceptions.ConnectionError: [Errno 0] Error", "trace": "self = <requests.adapters.HTTPAdapter object at 0x11aa9f550>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = Timeout(connect=10, read=10, total=None), verify = True, cert = None\nproxies = OrderedDict([('http', 'http://127.0.0.1:7890'), ('https', 'http://127.0.0.1:7890')])\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n>                   low_conn.endheaders()\n\n/Users/nali/anaconda3/lib/python3.7/site-packages/requests/adapters.py:467: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.connection.HTTPSConnection object at 0x11aa9f9e8>\nmessage_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/Users/nali/anaconda3/lib/python3.7/http/client.py:1224: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.connection.HTTPSConnection object at 0x11aa9f9e8>\nmessage_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/Users/nali/anaconda3/lib/python3.7/http/client.py:1016: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.connection.HTTPSConnection object at 0x11aa9f9e8>\ndata = b'GET /mapi/page HTTP/1.1\\r\\nHost: 127.0.0.1:7890\\r\\nUser-Agent: python-requests/2.25.0\\r\\nAccept-Encoding: gzip, defl....ACBDD0E38332E83A5A7010EEBBA214C8FEA1E7B381A5BC0E13933306C2345CF1;NICKNAME4=175%E6%98%B5%E7%A7%B0;UID4=239283;\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/Users/nali/anaconda3/lib/python3.7/http/client.py:956: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.connection.HTTPSConnection object at 0x11aa9f9e8>\n\n    def connect(self):\n        # Add certificate verification\n        conn = self._new_conn()\n        hostname = self.host\n        tls_in_tls = False\n    \n        if self._is_using_tunnel():\n            if self.tls_in_tls_required:\n                conn = self._connect_tls_proxy(hostname, conn)\n                tls_in_tls = True\n    \n            self.sock = conn\n    \n            # Calls self._set_hostport(), so self.host is\n            # self._tunnel_host below.\n            self._tunnel()\n            # Mark this connection as not reusable\n            self.auto_open = 0\n    \n            # Override the host with the one we're requesting data from.\n            hostname = self._tunnel_host\n    \n        server_hostname = hostname\n        if self.server_hostname is not None:\n            server_hostname = self.server_hostname\n    \n        is_time_off = datetime.date.today() < RECENT_DATE\n        if is_time_off:\n            warnings.warn(\n                (\n                    \"System time is way off (before {0}). This will probably \"\n                    \"lead to SSL verification errors\"\n                ).format(RECENT_DATE),\n                SystemTimeWarning,\n            )\n    \n        # Wrap socket using verification with the root certs in\n        # trusted_root_certs\n        default_ssl_context = False\n        if self.ssl_context is None:\n            default_ssl_context = True\n            self.ssl_context = create_urllib3_context(\n                ssl_version=resolve_ssl_version(self.ssl_version),\n                cert_reqs=resolve_cert_reqs(self.cert_reqs),\n            )\n    \n        context = self.ssl_context\n        context.verify_mode = resolve_cert_reqs(self.cert_reqs)\n    \n        # Try to load OS default certs if none are given.\n        # Works well on Windows (requires Python3.4+)\n        if (\n            not self.ca_certs\n            and not self.ca_cert_dir\n            and not self.ca_cert_data\n            and default_ssl_context\n            and hasattr(context, \"load_default_certs\")\n        ):\n            context.load_default_certs()\n    \n        self.sock = ssl_wrap_socket(\n            sock=conn,\n            keyfile=self.key_file,\n            certfile=self.cert_file,\n            key_password=self.key_password,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            ca_cert_data=self.ca_cert_data,\n            server_hostname=server_hostname,\n            ssl_context=context,\n>           tls_in_tls=tls_in_tls,\n        )\n\n/Users/nali/anaconda3/lib/python3.7/site-packages/urllib3/connection.py:421: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nkeyfile = None, certfile = None, cert_reqs = None\nca_certs = '/Users/nali/anaconda3/lib/python3.7/site-packages/certifi/cacert.pem'\nserver_hostname = '127.0.0.1', ssl_version = None, ciphers = None\nssl_context = <ssl.SSLContext object at 0x11aab3048>, ca_cert_dir = None\nkey_password = None, ca_cert_data = None, tls_in_tls = False\n\n    def ssl_wrap_socket(\n        sock,\n        keyfile=None,\n        certfile=None,\n        cert_reqs=None,\n        ca_certs=None,\n        server_hostname=None,\n        ssl_version=None,\n        ciphers=None,\n        ssl_context=None,\n        ca_cert_dir=None,\n        key_password=None,\n        ca_cert_data=None,\n        tls_in_tls=False,\n    ):\n        \"\"\"\n        All arguments except for server_hostname, ssl_context, and ca_cert_dir have\n        the same meaning as they do when using :func:`ssl.wrap_socket`.\n    \n        :param server_hostname:\n            When SNI is supported, the expected hostname of the certificate\n        :param ssl_context:\n            A pre-made :class:`SSLContext` object. If none is provided, one will\n            be created using :func:`create_urllib3_context`.\n        :param ciphers:\n            A string of ciphers we wish the client to support.\n        :param ca_cert_dir:\n            A directory containing CA certificates in multiple separate files, as\n            supported by OpenSSL's -CApath flag or the capath argument to\n            SSLContext.load_verify_locations().\n        :param key_password:\n            Optional password if the keyfile is encrypted.\n        :param ca_cert_data:\n            Optional string containing CA certificates in PEM format suitable for\n            passing as the cadata parameter to SSLContext.load_verify_locations()\n        :param tls_in_tls:\n            Use SSLTransport to wrap the existing socket.\n        \"\"\"\n        context = ssl_context\n        if context is None:\n            # Note: This branch of code and all the variables in it are no longer\n            # used by urllib3 itself. We should consider deprecating and removing\n            # this code.\n            context = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)\n    \n        if ca_certs or ca_cert_dir or ca_cert_data:\n            try:\n                context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)\n            except (IOError, OSError) as e:\n                raise SSLError(e)\n    \n        elif ssl_context is None and hasattr(context, \"load_default_certs\"):\n            # try to load OS default certs; works well on Windows (require Python3.4+)\n            context.load_default_certs()\n    \n        # Attempt to detect if we get the goofy behavior of the\n        # keyfile being encrypted and OpenSSL asking for the\n        # passphrase via the terminal and instead error out.\n        if keyfile and key_password is None and _is_key_file_encrypted(keyfile):\n            raise SSLError(\"Client private key is encrypted, password is required\")\n    \n        if certfile:\n            if key_password is None:\n                context.load_cert_chain(certfile, keyfile)\n            else:\n                context.load_cert_chain(certfile, keyfile, key_password)\n    \n        try:\n            if hasattr(context, \"set_alpn_protocols\"):\n                context.set_alpn_protocols(ALPN_PROTOCOLS)\n        except NotImplementedError:\n            pass\n    \n        # If we detect server_hostname is an IP address then the SNI\n        # extension should not be used according to RFC3546 Section 3.1\n        use_sni_hostname = server_hostname and not is_ipaddress(server_hostname)\n        # SecureTransport uses server_hostname in certificate verification.\n        send_sni = (use_sni_hostname and HAS_SNI) or (\n            IS_SECURETRANSPORT and server_hostname\n        )\n        # Do not warn the user if server_hostname is an invalid SNI hostname.\n        if not HAS_SNI and use_sni_hostname:\n            warnings.warn(\n                \"An HTTPS request has been made, but the SNI (Server Name \"\n                \"Indication) extension to TLS is not available on this platform. \"\n                \"This may cause the server to present an incorrect TLS \"\n                \"certificate, which can cause validation failures. You can upgrade to \"\n                \"a newer version of Python to solve this. For more information, see \"\n                \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html\"\n                \"#ssl-warnings\",\n                SNIMissingWarning,\n            )\n    \n        if send_sni:\n            ssl_sock = _ssl_wrap_socket_impl(\n                sock, context, tls_in_tls, server_hostname=server_hostname\n            )\n        else:\n>           ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls)\n\n/Users/nali/anaconda3/lib/python3.7/site-packages/urllib3/util/ssl_.py:432: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nssl_context = <ssl.SSLContext object at 0x11aab3048>, tls_in_tls = False\nserver_hostname = None\n\n    def _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname=None):\n        if tls_in_tls:\n            if not SSLTransport:\n                # Import error, ssl is not available.\n                raise ProxySchemeUnsupported(\n                    \"TLS in TLS requires support for the 'ssl' module\"\n                )\n    \n            SSLTransport._validate_ssl_context_for_tls_in_tls(ssl_context)\n            return SSLTransport(sock, ssl_context, server_hostname)\n    \n        if server_hostname:\n            return ssl_context.wrap_socket(sock, server_hostname=server_hostname)\n        else:\n>           return ssl_context.wrap_socket(sock)\n\n/Users/nali/anaconda3/lib/python3.7/site-packages/urllib3/util/ssl_.py:474: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLContext object at 0x11aab3048>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nserver_side = False, do_handshake_on_connect = True, suppress_ragged_eofs = True\nserver_hostname = None, session = None\n\n    def wrap_socket(self, sock, server_side=False,\n                    do_handshake_on_connect=True,\n                    suppress_ragged_eofs=True,\n                    server_hostname=None, session=None):\n        # SSLSocket class handles server_hostname encoding before it calls\n        # ctx._wrap_socket()\n        return self.sslsocket_class._create(\n            sock=sock,\n            server_side=server_side,\n            do_handshake_on_connect=do_handshake_on_connect,\n            suppress_ragged_eofs=suppress_ragged_eofs,\n            server_hostname=server_hostname,\n            context=self,\n>           session=session\n        )\n\n/Users/nali/anaconda3/lib/python3.7/ssl.py:412: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'ssl.SSLSocket'>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nserver_side = False, do_handshake_on_connect = True, suppress_ragged_eofs = True\nserver_hostname = None, context = <ssl.SSLContext object at 0x11aab3048>\nsession = None\n\n    @classmethod\n    def _create(cls, sock, server_side=False, do_handshake_on_connect=True,\n                suppress_ragged_eofs=True, server_hostname=None,\n                context=None, session=None):\n        if sock.getsockopt(SOL_SOCKET, SO_TYPE) != SOCK_STREAM:\n            raise NotImplementedError(\"only stream sockets are supported\")\n        if server_side:\n            if server_hostname:\n                raise ValueError(\"server_hostname can only be specified \"\n                                 \"in client mode\")\n            if session is not None:\n                raise ValueError(\"session can only be specified in \"\n                                 \"client mode\")\n        if context.check_hostname and not server_hostname:\n            raise ValueError(\"check_hostname requires server_hostname\")\n    \n        kwargs = dict(\n            family=sock.family, type=sock.type, proto=sock.proto,\n            fileno=sock.fileno()\n        )\n        self = cls.__new__(cls, **kwargs)\n        super(SSLSocket, self).__init__(**kwargs)\n        self.settimeout(sock.gettimeout())\n        sock.detach()\n    \n        self._context = context\n        self._session = session\n        self._closed = False\n        self._sslobj = None\n        self.server_side = server_side\n        self.server_hostname = context._encode_hostname(server_hostname)\n        self.do_handshake_on_connect = do_handshake_on_connect\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n    \n        # See if we are connected\n        try:\n            self.getpeername()\n        except OSError as e:\n            if e.errno != errno.ENOTCONN:\n                raise\n            connected = False\n        else:\n            connected = True\n    \n        self._connected = connected\n        if connected:\n            # create the SSL object\n            try:\n                self._sslobj = self._context._wrap_socket(\n                    self, server_side, self.server_hostname,\n                    owner=self, session=self._session,\n                )\n                if do_handshake_on_connect:\n                    timeout = self.gettimeout()\n                    if timeout == 0.0:\n                        # non-blocking\n                        raise ValueError(\"do_handshake_on_connect should not be specified for non-blocking sockets\")\n>                   self.do_handshake()\n\n/Users/nali/anaconda3/lib/python3.7/ssl.py:853: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0>\nblock = False\n\n    def do_handshake(self, block=False):\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\n        self._check_connected()\n        timeout = self.gettimeout()\n        try:\n            if timeout == 0.0 and block:\n                self.settimeout(None)\n>           self._sslobj.do_handshake()\nE           OSError: [Errno 0] Error\n\n/Users/nali/anaconda3/lib/python3.7/ssl.py:1117: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_page.TestPage object at 0x11aaa33c8>\ncase_data = {'check': {'check_type': 'Regular_check', 'expected_code': 200, 'expected_result': ['\"pageId\": \"${pageId}$\"']}, 'cookies': True, 'file': False, 'global_relevance': None, ...}\nsetupClass = {}\n\n    @pytest.mark.skipif(case_dict[\"test_info\"][\"product_version\"] in product_version,\n                        reason=\"该用例所属版本为：{0}，在本次排除版本{1}内\".format(case_dict[\"test_info\"][\"product_version\"],\n                                                                 product_version))\n    @pytest.mark.skipif(case_dict[\"test_info\"][\"case_level\"] not in case_level,\n                        reason=\"该用例的用例等级为：{0}，不在本次运行级别{1}内\".format(case_dict[\"test_info\"][\"case_level\"], case_level))\n    # @pytest.mark.run(order=case_dict[\"test_info\"][\"run_order\"])\n    @allure.severity(case_dict[\"test_info\"][\"case_level\"])\n    @pytest.mark.parametrize(\"case_data\", case_dict[\"test_case\"], ids=[])\n    @allure.story(\"page\")\n    def test_case(self, case_data, setupClass):\n        self.relevance = setupTest(relevance_path, case_data, setupClass)\n>       api_send_check(case_data, case_dict, case_path, self.relevance)\n\n/Users/nali/AutoApiTest/tests/TestScript/pageApi/test_page.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Users/nali/AutoApiTest/common/unit/api_send_check.py:28: in api_send_check\n    res = api_send.api_send(case_data, case_dict, case_path, relevance)\n/Users/nali/AutoApiTest/common/unit/api_send.py:125: in api_send\n    cookie=cookie)\n/Users/nali/AutoApiTest/common/unit/api_method.py:67: in get\n    response = requests.get(url=url, data=data, headers=headers, timeout=timeout, cookies=cookie)\n/Users/nali/anaconda3/lib/python3.7/site-packages/requests/api.py:76: in get\n    return request('get', url, params=params, **kwargs)\n/Users/nali/anaconda3/lib/python3.7/site-packages/requests/api.py:61: in request\n    return session.request(method=method, url=url, **kwargs)\n/Users/nali/anaconda3/lib/python3.7/site-packages/requests/sessions.py:542: in request\n    resp = self.send(prep, **send_kwargs)\n/Users/nali/anaconda3/lib/python3.7/site-packages/requests/sessions.py:655: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x11aa9f550>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = Timeout(connect=10, read=10, total=None), verify = True, cert = None\nproxies = OrderedDict([('http', 'http://127.0.0.1:7890'), ('https', 'http://127.0.0.1:7890')])\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n                        low_conn.send(b'\\r\\n')\n                        low_conn.send(i)\n                        low_conn.send(b'\\r\\n')\n                    low_conn.send(b'0\\r\\n\\r\\n')\n    \n                    # Receive the response from the server\n                    try:\n                        # For Python 2.7, use buffering of HTTP responses\n                        r = low_conn.getresponse(buffering=True)\n                    except TypeError:\n                        # For compatibility with Python 3.3+\n                        r = low_conn.getresponse()\n    \n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False\n                    )\n                except:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, reraise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n    \n        except (ProtocolError, socket.error) as err:\n>           raise ConnectionError(err, request=request)\nE           requests.exceptions.ConnectionError: [Errno 0] Error\n\n/Users/nali/anaconda3/lib/python3.7/site-packages/requests/adapters.py:498: ConnectionError"}, "steps": [{"name": "get请求接口", "status": "passed", "attachments": [{"name": "请求接口：", "source": "15ba6a64-9f85-455e-9281-75521bdcb35c-attachment.attach"}, {"name": "用例描述：", "source": "6c4ba73a-6c52-4dae-968b-1ef0638db450-attachment.attach"}, {"name": "请求地址", "source": "ee9002b8-2c41-40fe-bec8-11582a7e7def-attachment.attach"}, {"name": "请求头", "source": "739b0d3a-8e15-4d47-8148-b9d3c7fb5ddd-attachment.attach"}, {"name": "请求参数", "source": "0e61d1a3-5bf2-4b48-91c8-857da88d7b12-attachment.attach"}], "start": 1617805033328, "stop": 1617805033332}], "attachments": [{"name": "log", "source": "86a7fd04-dd7b-4d21-96ee-4b5f367f394c-attachment.txt", "type": "text/plain"}, {"name": "stdout", "source": "8ac9ec95-6753-42ba-a1bb-816ccad03a6c-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "login", "value": "{'test_name': 'login_h5', 'info': '密码登录m站', 'is_run': None, 'host': '${HOST1}$', 'headers': '${headers1}$', 'address': '/passport/api/pwdLogin', 'http_type': 'https', 'request_type': 'post_cookie', 'parameter_type': 'data', 'parameter': {'passport': 17521200974, 'password': 'anqi666', 'passportType': 1, 'sign': 'F017A0CD674A8B7A4F52B56898D78E6A'}, 'timeout': 10, 'cookies': False, 'check': {'expected_result': None, 'check_type': 'no_check', 'expected_code': None}, 'file': False, 'global_relevance': None, 'relevance': None}"}, {"name": "case_data", "value": "{'test_name': 'page_1', 'info': '频道数据', 'is_run': None, 'request_type': 'get', 'parameter_type': 'data', 'parameter': {'pageId': '${pageId}$', 'pageSource': '${pageSource}$'}, 'cookies': True, 'timeout': 10, 'check': {'expected_result': ['\"pageId\": \"${pageId}$\"'], 'check_type': 'Regular_check', 'expected_code': 200}, 'file': False, 'global_relevance': None, 'relevance': None}"}], "start": 1617805033322, "stop": 1617805033351, "uuid": "9f353d71-1da2-454d-9574-65035e03b997", "historyId": "eb334c558b3408a2ad136d8fece96b42", "testCaseId": "872f7fa790f35b7d880324092f6b6e0c", "fullName": "tests.TestScript.pageApi.test_page.TestPage#test_case", "labels": [{"name": "story", "value": "page"}, {"name": "feature", "value": "page"}, {"name": "severity", "value": "blocker"}, {"name": "tag", "value": "@pytest.mark.skipif(False, reason='该用例的用例等级为：blocker，不在本次运行级别['blocker', 'critical', 'normal', 'minor']内')"}, {"name": "parentSuite", "value": "tests.TestScript.pageApi"}, {"name": "suite", "value": "test_page"}, {"name": "subSuite", "value": "TestPage"}, {"name": "host", "value": "anqidediannao.local"}, {"name": "thread", "value": "90397-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.TestScript.pageApi.test_page"}]}